import requests
import json
import os
from typing import List, Dict, Any
from dotenv import load_dotenv

load_dotenv()

class GeminiClient:
    def __init__(self):
        self.api_key = os.getenv("GEMINI_API_KEY")
        if not self.api_key:
            raise ValueError("GEMINI_API_KEY is not set. Please define it in your environment or .env file.")
        self.base_url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent"
    
    def generate_questions(self, topic: str, number_questions: int, difficulty: str) -> List[Dict[str, Any]]:
        """
        Generate questions using Gemini LLM
        
        Args:
            topic (str): The topic for question generation
            number_questions (int): Number of questions to generate
            
        Returns:
            List[Dict]: List of generated questions with options and answers
        """
        
        prompt = f"""
        Generate {number_questions} multiple choice questions about the topic: "{topic}".
        Difficulty level: {difficulty}.
        
        Requirements:
        1. Each question should have exactly 4 options.
        2. Some questions should have multiple correct answers (2-3). Others can have exactly one.
        3. Include a short 1-2 sentence explanation for the correct answer(s).
        4. Questions should be educational and appropriate.
        5. For multiple-answer questions, make sure answers contain ALL correct options.
        
        Respond ONLY with valid JSON in the following format (no markdown, no extra text):
        {{
            "questions": [
                {{
                    "question": "Your question here?",
                    "options": ["Option A", "Option B", "Option C", "Option D"],
                    "answers": ["Option A"],  
                    "explanation": "Why the answer(s) are correct in 1-2 sentences."
                }}
            ]
        }}
        
        Generate exactly {number_questions} questions.
        """
        
        payload = {
            "contents": [
                {
                    "parts": [
                        {
                            "text": prompt
                        }
                    ]
                }
            ]
        }
        
        headers = {
            'X-goog-api-key': self.api_key,
            'Content-Type': 'application/json'
        }
        
        try:
            response = requests.post(
                self.base_url, 
                headers=headers, 
                json=payload,
                timeout=30
            )
            response.raise_for_status()
            
            # Parse the response
            result = response.json()
            
            # Extract the generated text from Gemini response
            if 'candidates' in result and len(result['candidates']) > 0:
                generated_text = result['candidates'][0]['content']['parts'][0]['text']
                
                # Clean up the response to extract JSON
                # Remove markdown code blocks if present
                if '```json' in generated_text:
                    generated_text = generated_text.split('```json')[1].split('```')[0]
                elif '```' in generated_text:
                    generated_text = generated_text.split('```')[1].split('```')[0]
                
                # Parse the JSON response
                questions_data = json.loads(generated_text.strip())
                return questions_data.get('questions', [])
            else:
                raise Exception("No content generated by Gemini")
                
        except requests.exceptions.RequestException as e:
            raise Exception(f"Request failed: {str(e)}")
        except json.JSONDecodeError as e:
            raise Exception(f"Failed to parse JSON response: {str(e)}")
        except Exception as e:
            raise Exception(f"Error generating questions: {str(e)}")